<!--
     Copyright 2013 nBuildKit. Licensed under the Apache License, Version 2.0.
-->

<Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'
         ToolsVersion="11.0">
    <PropertyGroup>
        <!-- Defines whether the current script file has been loaded / imported or not -->
        <ExistsExtensionsInvokeNodeTool>true</ExistsExtensionsInvokeNodeTool>

        <!--
            For MsBuild versions 4.0 through to 12.0 the tasks dll was in an assembly that contains the version in the file name.
            However starting with version 14 that is no longer the case so have to differentiate between these cases.
        -->
        <MsBuildTasksAssembly>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll</MsBuildTasksAssembly>
        <MsBuildTasksAssembly Condition="!Exists('$(MsBuildTasksAssembly)')">$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll</MsBuildTasksAssembly>
    </PropertyGroup>

    <UsingTask TaskName="InvokeNodeTool"
               TaskFactory="CodeTaskFactory"
               AssemblyFile="$(MsBuildTasksAssembly)">
        <ParameterGroup>
            <NodeExecutablePath ParameterType="System.String" Required="true" />
            <AdditionalEnvironmentPaths ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" />
            <ToolPath ParameterType="System.String" Required="true" />
            <Arguments ParameterType="System.String" Required="true" />
            <WorkingDirectory ParameterType="System.String" Required="true" />
            <IgnoreErrors ParameterType="System.Boolean" Required="true" />
            <IgnoreExitCode ParameterType="System.Boolean" Required="true" />
        </ParameterGroup>
        <Task>
            <Code Type="Method" Language="cs">
                <![CDATA[
                    public override bool Execute()
                    {
                        try
                        {
                            // If the node tool is installed on the machine there will be a 'cmd' type script
                            // that can be used to invoke it. In that case we are probably passed the path to this cmd script
                            // or just the name of the tool, e.g. 'npm'. In that case we just execute the tool with cmd (running
                            // it straight with System.Diagnostics.Process doesn't work, it complains about the node tool not being
                            // a windows executable).
                            //
                            // If we got passed the path to a js file then we assume that the tools are a local install and
                            // we invoke them through node.
                            var isJsFile = System.IO.Path.GetExtension(ToolPath).Equals(".js");
                            var toolFileName = (!isJsFile)
                                ? "cmd.exe"
                                : NodeExecutablePath;
                            var toolArguments = (!isJsFile)
                                ? string.Format("/c {0} {1}", ToolPath, Arguments)
                                : string.Format("{0} {1}", ToolPath, Arguments);

                            var info = new System.Diagnostics.ProcessStartInfo
                                    {
                                        FileName = toolFileName,
                                        Arguments = toolArguments,
                                        WorkingDirectory = WorkingDirectory,
                                        UseShellExecute = false,
                                        RedirectStandardOutput = true,
                                        RedirectStandardError = true,
                                    };
                            info.EnvironmentVariables["PATH"] = System.Environment.GetEnvironmentVariable("PATH");

                            var nodeWorkingDirectory = System.IO.Path.GetDirectoryName(NodeExecutablePath);
                            if (!string.IsNullOrWhiteSpace(nodeWorkingDirectory))
                            {
                                info.EnvironmentVariables["PATH"] += ";" + nodeWorkingDirectory;
                            }

                            if ((AdditionalEnvironmentPaths != null) && (AdditionalEnvironmentPaths.Length > 0))
                            {
                                foreach(var path in AdditionalEnvironmentPaths)
                                {
                                    info.EnvironmentVariables["PATH"] += ";" + path.ItemSpec;
                                }
                            }

                            Log.LogMessage(
                                MessageImportance.Low,
                                string.Format(
                                    "Invoking: {0} with arguments: {1}",
                                    info.FileName,
                                    info.Arguments));

                            var process = new System.Diagnostics.Process();
                            process.StartInfo = info;
                            process.OutputDataReceived +=
                                (s, e) =>
                                {
                                    if (!string.IsNullOrWhiteSpace(e.Data))
                                    {
                                        Log.LogMessage(MessageImportance.Normal, e.Data);
                                    }
                                };
                            process.ErrorDataReceived +=
                                (s, e) =>
                                {
                                    if (!string.IsNullOrWhiteSpace(e.Data))
                                    {
                                        if (IgnoreErrors)
                                        {
                                            Log.LogWarning(e.Data);
                                        }
                                        else
                                        {
                                            Log.LogError(e.Data);
                                        }
                                    }
                                };
                            process.Start();

                            process.BeginOutputReadLine();
                            process.BeginErrorReadLine();
                            process.WaitForExit();

                            if (process.ExitCode != 0)
                            {
                                var text = string.Format(
                                    "{0} exited with a non-zero exit code. Exit code was: {1}",
                                    System.IO.Path.GetFileName(process.StartInfo.FileName),
                                    process.ExitCode);
                                if (IgnoreExitCode)
                                {
                                    Log.LogWarning(text);
                                }
                                else
                                {
                                    Log.LogError(text);
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            Log.LogError(e.ToString());
                        }

                        // Log.HasLoggedErrors is true if the task logged any errors -- even if they were logged
                        // from a task's constructor or property setter. As long as this task is written to always log an error
                        // when it fails, we can reliably return HasLoggedErrors.
                        return !Log.HasLoggedErrors;
                    }
                ]]>
            </Code>
        </Task>
    </UsingTask>
</Project>