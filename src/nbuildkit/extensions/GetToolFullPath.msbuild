
<!--
     Copyright 2014 nBuildKit. Licensed under the Apache License, Version 2.0.
-->

<Project
    ToolsVersion="11.0"
    xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <!-- Defines whether the current script file has been loaded / imported or not -->
        <ExistsExtensionsGetToolFullPath>true</ExistsExtensionsGetToolFullPath>

        <!--
            For MsBuild versions 4.0 through to 12.0 the tasks dll was in an assembly that contains the version in the file name.
            However starting with version 14 that is no longer the case so have to differentiate between these cases.
        -->
        <MsBuildTasksAssembly>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll</MsBuildTasksAssembly>
        <MsBuildTasksAssembly Condition="!Exists('$(MsBuildTasksAssembly)')">$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll</MsBuildTasksAssembly>
    </PropertyGroup>

    <UsingTask
        AssemblyFile="$(MsBuildTasksAssembly)"
        TaskFactory="CodeTaskFactory"
        TaskName="GetToolFullPath">
        <ParameterGroup>
            <Tool
                ParameterType="System.String"
                Required="true" />
            <Path
                Output="true"
                ParameterType="System.String" />
        </ParameterGroup>
        <Task>
            <Code
                Language="cs"
                Type="Method">
                <![CDATA[
                    public override bool Execute()
                    {
                        Log.LogMessage(
                            MessageImportance.Low,
                            string.Format(
                                "Searching for full path of {0}",
                                Tool));

                        Path = Tool;
                        if (!System.IO.Path.IsPathRooted(Tool))
                        {
                            Path = System.IO.Path.GetFullPath(Tool);
                        }

                        if (!System.IO.File.Exists(Path))
                        {
                            // Fall back to using the 'where' command. This really only searches based on the file name so ...
                            var info = new System.Diagnostics.ProcessStartInfo
                                {
                                    FileName = "where",
                                    Arguments = System.IO.Path.GetFileName(Tool),
                                    UseShellExecute = false,
                                    RedirectStandardOutput = true,
                                    RedirectStandardError = true,
                                };

                            var text = new System.Text.StringBuilder();
                            var process = new System.Diagnostics.Process();
                            process.StartInfo = info;
                            process.OutputDataReceived +=
                                (s, e) =>
                                {
                                    if (!string.IsNullOrWhiteSpace(e.Data))
                                    {
                                        text.AppendLine(e.Data);
                                    }
                                };
                            process.ErrorDataReceived +=
                                (s, e) =>
                                {
                                    if (!string.IsNullOrWhiteSpace(e.Data))
                                    {
                                        Log.LogError(e.Data);
                                    }
                                };
                            try
                            {
                                process.Start();

                                process.BeginOutputReadLine();
                                process.BeginErrorReadLine();
                                process.WaitForExit();
                            }
                            catch(System.ComponentModel.Win32Exception)
                            {
                                Log.LogMessage(
                                    MessageImportance.Low,
                                    string.Format(
                                        "{0} exited with a non-zero exit code. Exit code was: {1}",
                                        System.IO.Path.GetFileName(process.StartInfo.FileName),
                                        process.ExitCode));

                                // The where command is probably not on the path. So we just return the
                                // input value
                                Path = Tool;
                            }

                            if (process.ExitCode != 0)
                            {
                                Log.LogMessage(
                                    MessageImportance.Low,
                                    string.Format(
                                        "{0} exited with a non-zero exit code. Exit code was: {1}",
                                        System.IO.Path.GetFileName(process.StartInfo.FileName),
                                        process.ExitCode));
                            }

                            // just return first match
                            var output = text.ToString();
                            if (!string.IsNullOrWhiteSpace(output))
                            {
                                Path = output.Substring(0, output.IndexOf(Environment.NewLine));
                            }
                        }

                        Log.LogMessage(
                            MessageImportance.Low,
                            string.Format(
                                "Full path for tool: {0} is: {1}",
                                Tool,
                                Path));

                        // Log.HasLoggedErrors is true if the task logged any errors -- even if they were logged
                        // from a task's constructor or property setter. As long as this task is written to always log an error
                        // when it fails, we can reliably return HasLoggedErrors.
                        return !Log.HasLoggedErrors;
                    }
                    ]]>
            </Code>
        </Task>
    </UsingTask>
</Project>