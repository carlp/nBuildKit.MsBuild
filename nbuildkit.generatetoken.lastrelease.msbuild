<?xml version="1.0" encoding="utf-8"?>
<Project
    ToolsVersion="11.0"
    xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
        <!-- Defines whether the current script file has been loaded / imported or not -->
        <ExistsNBuildKitGenerateTokenLastRelease>true</ExistsNBuildKitGenerateTokenLastRelease>
    </PropertyGroup>

    <Import
        Condition="Exists('$(DirNBuildKitMsBuildShared)\shared.importsharedsettings.props') AND '$(ExistsSharedImportSharedSettings)' != 'true' "
        Project="$(DirNBuildKitMsBuildShared)\shared.importsharedsettings.props" />

    <PropertyGroup>
        <FileNBuildKitLastRelease>$(DirBuildTemp)\nbuildkit.lastrelease.json</FileNBuildKitLastRelease>
    </PropertyGroup>

        <GetLastRelease_LocalTask_GetLatestNBuildKitVersionFromNuGet NuGetPath="$(ToolsExternalNuGetPath)">
    <Target
        Condition="!Exists('$FileNBuildKitLastRelease')"
        Name="_NBuildKit_GenerateToken_LastRelease_FromNuGet">
            <Output
                PropertyName="NBuildKitLatestMajorVersion"
                TaskParameter="Major" />
            <Output
                PropertyName="NBuildKitLatestMinorVersion"
                TaskParameter="Minor" />
            <Output
                PropertyName="NBuildKitLatestPatchVersion"
                TaskParameter="Patch" />
        </GetLastRelease_LocalTask_GetLatestNBuildKitVersionFromNuGet>

        <CreateProperty
            Value="$([System.IO.Path]::GetDirectoryName('$(FileNBuildKitLastRelease)'))">
            <Output
                PropertyName="DirToCreate"
                TaskParameter="Value" />
        </CreateProperty>
        <MakeDir
            Condition="!Exists('$(DirToCreate)') AND '$(ShouldExecute)' == 'true' "
            Directories="$(DirToCreate)" />

        <ItemGroup>
            <Items_ReleaseVersion Include="{" />

            <Items_ReleaseVersion Include="    &quot;Major&quot;: &quot;$(NBuildKitLatestMajorVersion)&quot;," />
            <Items_ReleaseVersion Include="    &quot;Minor&quot;: &quot;$(NBuildKitLatestMinorVersion)&quot;," />
            <Items_ReleaseVersion Include="    &quot;Patch&quot;: &quot;$(NBuildKitLatestPatchVersion)&quot;," />

            <Items_ReleaseVersion Include="}" />
        </ItemGroup>

        <WriteLinesToFile
            Condition="!Exists('$(FileNBuildKitLastRelease)') AND '$(ShouldExecute)' == 'true' "
            File="$(FileNBuildKitLastRelease)"
            Lines="@(Items_ReleaseVersion)"
            Overwrite="true" />
    </Target>

        <GetLastRelease_LocalTask_GetLastReleaseVersionFromFile VersionFile="$(FileNBuildKitLastRelease)">
    <Target
        DependsOnTargets="_NBuildKit_GenerateToken_LastRelease_FromNuGet"
        Name="nbuildkit_generatetoken_lastrelease">
            <Output
                PropertyName="NBuildKitLatestMajorVersion"
                TaskParameter="VersionMajor" />
            <Output
                PropertyName="NBuildKitLatestMinorVersion"
                TaskParameter="VersionMinor" />
            <Output
                PropertyName="NBuildKitLatestPatchVersion"
                TaskParameter="VersionPatch" />
        </GetLastRelease_LocalTask_GetLastReleaseVersionFromFile>

        <ItemGroup>
            <TemplateTokens Include="NBuildKitLatestMajorVersion">
                <ReplacementValue>$(NBuildKitLatestMajorVersion)</ReplacementValue>
            </TemplateTokens>
            <TemplateTokens Include="NBuildKitLatestMinorVersion">
                <ReplacementValue>$(NBuildKitLatestMinorVersion)</ReplacementValue>
            </TemplateTokens>
            <TemplateTokens Include="NBuildKitLatestPatchVersion">
                <ReplacementValue>$(NBuildKitLatestPatchVersion)</ReplacementValue>
            </TemplateTokens>
            <TemplateTokens Include="VersionNBuildKitLastRelease">
                <ReplacementValue>$(NBuildKitLatestMajorVersion).$(NBuildKitLatestMinorVersion).$(NBuildKitLatestPatchVersion)</ReplacementValue>
            </TemplateTokens>
        </ItemGroup>
    </Target>

    <UsingTask
        AssemblyFile="$(MsBuildTasksAssembly)"
        TaskFactory="CodeTaskFactory"
        TaskName="GetLastRelease_LocalTask_GetLatestNBuildKitVersionFromNuGet">
        <ParameterGroup>
            <NuGetPath
                ParameterType="System.String"
                Required="true" />
            <Major
                Output="true"
                ParameterType="System.Int32" />
            <Minor
                Output="true"
                ParameterType="System.Int32" />
            <Patch
                Output="true"
                ParameterType="System.Int32" />
        </ParameterGroup>
        <Task>
            <Code
                Language="cs"
                Type="Method">
                <![CDATA[
                    public override bool Execute()
                    {
                        var info = new System.Diagnostics.ProcessStartInfo
                                {
                                    FileName = NuGetPath,
                                    Arguments = "list packageId:NBuildKit.MsBuild",
                                    UseShellExecute = false,
                                    RedirectStandardOutput = true,
                                    RedirectStandardError = true,
                                };

                        Log.LogMessage(MessageImportance.Low, string.Format("{0} {1}", info.FileName, info.Arguments));

                        var text = new System.Text.StringBuilder();
                        var process = new System.Diagnostics.Process();
                        process.StartInfo = info;
                        process.OutputDataReceived +=
                            (s, e) =>
                            {
                                if (!string.IsNullOrWhiteSpace(e.Data))
                                {
                                    text.Append(e.Data);
                                }
                            };
                        process.ErrorDataReceived +=
                            (s, e) =>
                            {
                                if (!string.IsNullOrWhiteSpace(e.Data))
                                {
                                    Log.LogError(e.Data);
                                }
                            };
                        process.Start();

                        process.BeginOutputReadLine();
                        process.BeginErrorReadLine();
                        process.WaitForExit();

                        if (process.ExitCode != 0)
                        {
                            Log.LogError(
                                string.Format(
                                    "{0} exited with a non-zero exit code. Exit code was: {1}",
                                    System.IO.Path.GetFileName(process.StartInfo.FileName),
                                    process.ExitCode));
                            return false;
                        }

                        Log.LogMessage(MessageImportance.Normal, string.Format("Nuget response: {0}", text.ToString()));

                        try
                        {
                            string listText = text.ToString();
                            const string nbuildKitVersionStart = "nBuildKit.Msbuild ";
                            var index = listText.IndexOf(nbuildKitVersionStart, StringComparison.OrdinalIgnoreCase);
                            var startIndex = index + nbuildKitVersionStart.Length;

                            // The index of the next entry for nBuildKit
                            var nextIndex = listText.IndexOf("nBuildKit", index + nbuildKitVersionStart.Length, StringComparison.OrdinalIgnoreCase);
                            var length =  (nextIndex - startIndex);

                            var versionText = string.Empty;
                            if (length > -1)
                            {
                                versionText = listText.Substring(startIndex, length).Trim();
                            }
                            else
                            {
                                versionText = listText.Substring(startIndex).Trim();
                            }
                            var version = new Version(versionText);
                            Major = version.Major;
                            Minor = version.Minor;
                            Patch = version.Build;
                        }
                        catch(Exception e)
                        {
                            Log.LogError(e.ToString());
                        }

                        // Log.HasLoggedErrors is true if the task logged any errors -- even if they were logged
                        // from a task's constructor or property setter. As long as this task is written to always log an error
                        // when it fails, we can reliably return HasLoggedErrors.
                        return !Log.HasLoggedErrors;
                    }
                ]]>
            </Code>
        </Task>
    </UsingTask>

    <UsingTask
        AssemblyFile="$(MsBuildTasksAssembly)"
        TaskFactory="CodeTaskFactory"
        TaskName="GetLastRelease_LocalTask_GetLastReleaseVersionFromFile">
        <ParameterGroup>
            <VersionFile
                ParameterType="System.String"
                Required="true" />
            <VersionMajor
                Output="true"
                ParameterType="System.String" />
            <VersionMinor
                Output="true"
                ParameterType="System.String" />
            <VersionPatch
                Output="true"
                ParameterType="System.String" />
        </ParameterGroup>
        <Task>
            <Code
                Language="cs"
                Type="Method">
                <![CDATA[
                    public override bool Execute()
                    {
                        try
                        {
                            string text;
                            using (var reader = new System.IO.StreamReader(VersionFile))
                            {
                                text = reader.ReadToEnd();
                            }

                            const string majorVersionStart = "\"Major\": \"";
                            var index = text.IndexOf(majorVersionStart);
                            VersionMajor = text.Substring(
                                index + majorVersionStart.Length,
                                text.IndexOf("\"", index + majorVersionStart.Length) - (index + majorVersionStart.Length));

                            const string minorVersionStart = "\"Minor\": \"";
                            index = text.IndexOf(minorVersionStart);
                            VersionMinor = text.Substring(
                                index + minorVersionStart.Length,
                                text.IndexOf("\"", index + minorVersionStart.Length) - (index + minorVersionStart.Length));

                            const string patchVersionStart = "\"Patch\": \"";
                            index = text.IndexOf(patchVersionStart);
                            VersionPatch = text.Substring(
                                index + patchVersionStart.Length,
                                text.IndexOf("\"", index + patchVersionStart.Length) - (index + patchVersionStart.Length));
                        }
                        catch(Exception e)
                        {
                            Log.LogError(e.ToString());
                        }

                        // Log.HasLoggedErrors is true if the task logged any errors -- even if they were logged
                        // from a task's constructor or property setter. As long as this task is written to always log an error
                        // when it fails, we can reliably return HasLoggedErrors.
                        return !Log.HasLoggedErrors;
                    }
                ]]>
            </Code>
        </Task>
    </UsingTask>
</Project>